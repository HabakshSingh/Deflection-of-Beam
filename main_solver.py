# -*- coding: utf-8 -*-
"""Beam_Deflection_Calculator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qyCQAv2NhFUVvQD8dAw-XpYLQqL1BZFx
"""

import pandas as pd
import sympy as sp
from sympy import SingularityFunction as SF
from fractions import Fraction

x=sp.symbols('x')
P,E,I,L,M,q=sp.symbols('P,E,I,L,M,q', positive=True)
w=sp.Function('w')(x)

gde_lhs=0
gde_rhs=0
left_end_point_load=0
right_end_point_load=0
left_end_moment_load=0
right_end_moment_load=0
def initialise_global_variables():
  global gde_lhs,gde_rhs,left_end_moment_load,left_end_point_load,right_end_moment_load,right_end_point_load
  gde_lhs=0
  gde_rhs=0
  left_end_point_load=0
  right_end_point_load=0
  left_end_moment_load=0
  right_end_moment_load=0
def formulate_point_loads():
  point_df=pd.read_csv("AppData\Files\point_load.csv", dtype=str)
  global gde_rhs,gde_lhs,left_end_point_load,right_end_point_load
  for index,row in point_df.iterrows():
    if row["LOCATION"]=='1':
      right_end_point_load= right_end_point_load+ Fraction(row["MULTIPLIER"])*P
    elif row["LOCATION"]=='0':
      left_end_point_load= left_end_point_load+ Fraction(row["MULTIPLIER"])*P
    else:
      gde_rhs=gde_rhs+Fraction(row["MULTIPLIER"])*P*SF(x,Fraction(row["LOCATION"])*L,-1)
    
def formulate_moment_loads():
  moment_df=pd.read_csv("AppData\Files\moment_load.csv", dtype=str)
  global gde_rhs,gde_lhs,left_end_moment_load,right_end_moment_load
  for index,row in moment_df.iterrows():
    if row["LOCATION"]=='1':
      right_end_moment_load= right_end_moment_load+ Fraction(row["MULTIPLIER"])*M
    elif row["LOCATION"]=='0':
      left_end_moment_load= left_end_moment_load+ Fraction(row["MULTIPLIER"])*M
    else:
      gde_rhs=gde_rhs+Fraction(row["MULTIPLIER"])*M*SF(x,Fraction(row["LOCATION"])*L,-2)

def formulate_distributed_loads():
  distributed_df=pd.read_csv("AppData\Files\distributed_load.csv", dtype=str)
  global gde_rhs
  for index,row in distributed_df.iterrows():
    coefficients=row["COEFFICIENTS"].split()
    polynomial=0
    order=0
    for m in coefficients:
      if m.isdigit():
        polynomial=polynomial+int(m)*(x/L)**order
      else:
        polynomial=polynomial+Fraction(m)*(x/L)**order
      order=order+1
    polynomial=polynomial*q
    #display(polynomial)
    if row["LEFT_LIMIT"]=='0' and row["RIGHT_LIMIT"]=='1':
       gde_rhs=gde_rhs+polynomial
    elif row["LEFT_LIMIT"]=='0' and row["RIGHT_LIMIT"]!='1':
       gde_rhs=gde_rhs+polynomial-polynomial*SF(x,Fraction(row["RIGHT_LIMIT"])*L,0)
    elif row["LEFT_LIMIT"]!='0' and row["RIGHT_LIMIT"]=='1':
       gde_rhs=gde_rhs+polynomial*SF(x,Fraction(row["LEFT_LIMIT"])*L,0)
    else:
       gde_rhs=gde_rhs+polynomial*SF(x,Fraction(row["LEFT_LIMIT"])*L,0)-polynomial*SF(x,Fraction(row["RIGHT_LIMIT"])*L,0)

def formulate_gde():
  gde_lhs=E*I*sp.diff(w,(x,4))
  governing_eq=sp.Eq(gde_lhs,gde_rhs)
  return governing_eq
  
def solve_gde(governing_eq):
  soln=sp.dsolve(governing_eq).rewrite(sp.Piecewise).simplify()
  soln_interim=soln.rhs
  return soln

def apply_boundary_conditions(sol1):
  global left_end_moment_load, left_end_point_load, right_end_moment_load, right_end_point_load
  support=pd.read_csv(r"AppData\Files\boundary_condition.csv", dtype=str)
  #display(support['LEFT'].iloc[0],support['RIGHT'].iloc[0])
  #support['LEFT'].iloc[0]='fixed'
  #support['RIGHT'].iloc[0]='free'
  if support['LEFT'].iloc[0]=='fixed':
    leftbc1_lhscondition=sp.diff(sol1.rhs,(x,1)).subs(x,0)
    leftbc1_rhscondition=0
    leftbc1_eq=sp.Eq(leftbc1_lhscondition,leftbc1_rhscondition)
    leftbc2_lhscondition=(sol1.rhs).subs(x,0)
    leftbc2_rhscondition=0
    leftbc2_eq=sp.Eq(leftbc2_lhscondition,leftbc2_rhscondition)
  elif support['LEFT'].iloc[0]=='hinged':
    leftbc1_lhscondition=sp.diff(sol1.rhs,(x,2)).subs(x,0)-left_end_moment_load/(E*I)
    leftbc1_rhscondition=0
    leftbc1_eq=sp.Eq(leftbc1_lhscondition,leftbc1_rhscondition)
    leftbc2_lhscondition=sol1.rhs.subs(x,0)
    leftbc2_rhscondition=0
    leftbc2_eq=sp.Eq(leftbc2_lhscondition,leftbc2_rhscondition)
  elif support['LEFT'].iloc[0]=='free':
    leftbc1_lhscondition=sp.diff(sol1.rhs,(x,2)).subs(x,0)-left_end_moment_load/(E*I)
    leftbc1_rhscondition=0
    leftbc1_eq=sp.Eq(leftbc1_lhscondition,leftbc1_rhscondition)
    leftbc2_lhscondition=sp.diff(sol1.rhs,(x,3)).subs(x,0)-left_end_point_load/(E*I)
    leftbc2_rhscondition=0
    leftbc2_eq=sp.Eq(leftbc2_lhscondition,leftbc2_rhscondition)
  elif support['LEFT'].iloc[0]=='roller':
    leftbc1_lhscondition=sp.diff(sol1.rhs,(x,1)).subs(x,0)
    leftbc1_rhscondition=0
    leftbc1_eq=sp.Eq(leftbc1_lhscondition,leftbc1_rhscondition)
    leftbc2_lhscondition=sp.diff(sol1.rhs,(x,3)).subs(x,0)-left_end_point_load/(E*I)
    leftbc2_rhscondition=0
    leftbc2_eq=sp.Eq(leftbc2_lhscondition,leftbc2_rhscondition)
  if support['RIGHT'].iloc[0]=='fixed':
    rightbc1_lhscondition=sp.diff(sol1.rhs,(x,1)).subs(x,L)
    rightbc1_rhscondition=0
    rightbc1_eq=sp.Eq(rightbc1_lhscondition,rightbc1_rhscondition)
    rightbc2_lhscondition=sol1.rhs.subs(x,L)
    rightbc2_rhscondition=0
    rightbc2_eq=sp.Eq(rightbc2_lhscondition,rightbc2_rhscondition)
  elif support['RIGHT'].iloc[0]=='hinged':
    rightbc1_lhscondition=sp.diff(sol1.rhs,(x,2)).subs(x,L)-right_end_moment_load/(E*I)
    rightbc1_rhscondition=0
    rightbc1_eq=sp.Eq(rightbc1_lhscondition,rightbc1_rhscondition)
    rightbc2_lhscondition=sol1.rhs.subs(x,L)
    rightbc2_rhscondition=0
    rightbc2_eq=sp.Eq(rightbc2_lhscondition,rightbc2_rhscondition)
  elif support['RIGHT'].iloc[0]=='free':
    rightbc1_lhscondition=sp.diff(sol1.rhs,(x,2)).subs(x,L)-right_end_moment_load/(E*I)
    rightbc1_rhscondition=0
    rightbc1_eq=sp.Eq(rightbc1_lhscondition,rightbc1_rhscondition)
    rightbc2_lhscondition=sp.diff(sol1.rhs,(x,3)).subs(x,L)-right_end_point_load/(E*I)
    rightbc2_rhscondition=0
    rightbc2_eq=sp.Eq(rightbc2_lhscondition,rightbc2_rhscondition)
  elif support['RIGHT'].iloc[0]=='roller':
    rightbc1_lhscondition=sp.diff(sol1.rhs,(x,1)).subs(x,L)
    rightbc1_rhscondition=0
    rightbc1_eq=sp.Eq(rightbc1_lhscondition,rightbc1_rhscondition)
    rightbc2_lhscondition=sp.diff(sol1.rhs,(x,3)).subs(x,L)-right_end_point_load/(E*I)
    rightbc2_rhscondition=0
    rightbc2_eq=sp.Eq(rightbc2_lhscondition,rightbc2_rhscondition)
  constants = sp.solve([leftbc1_lhscondition,leftbc2_lhscondition,rightbc1_lhscondition,rightbc2_lhscondition])
  
  #display(leftbc1_eq)
  #display(leftbc2_eq)
  #display(rightbc1_eq)
  #display(rightbc2_eq)
  #display(leftbc1_lhscondition,leftbc2_lhscondition,rightbc1_lhscondition,rightbc2_lhscondition)
  #display(constants)
  if isinstance(constants, list): return sol1.subs(constants[0])
  else: return sol1.subs(constants)

'''
formulate_point_loads()
formulate_moment_loads()
formulate_distributed_loads()

display(gde_rhs,gde_lhs,left_end_point_load,right_end_point_load, left_end_moment_load,right_end_moment_load)

formulate_gde()

solution=solve_gde(formulate_gde())

apply_boundary_conditions(solution)

final_solution=apply_boundary_conditions(solution)

final_solution.rhs.simplify()

(final_solution.rhs).subs([(x,L)])
'''
